<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Sat Dec 28 11:08:51 MSK 2013 -->
<TITLE>
Video
</TITLE>

<META NAME="date" CONTENT="2013-12-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Video";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
OpenCV 2.4.8</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/opencv/video/Video.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Video.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.opencv.video</FONT>
<BR>
Class Video</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.opencv.video.Video</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Video</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#OPTFLOW_FARNEBACK_GAUSSIAN">OPTFLOW_FARNEBACK_GAUSSIAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#OPTFLOW_LK_GET_MIN_EIGENVALS">OPTFLOW_LK_GET_MIN_EIGENVALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#OPTFLOW_USE_INITIAL_FLOW">OPTFLOW_USE_INITIAL_FLOW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#Video()">Video</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)">buildOpticalFlowPyramid</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;img,
                        java.util.List&lt;<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&gt;&nbsp;pyramid,
                        <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                        int&nbsp;maxLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)">buildOpticalFlowPyramid</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;img,
                        java.util.List&lt;<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&gt;&nbsp;pyramid,
                        <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                        int&nbsp;maxLevel,
                        boolean&nbsp;withDerivatives,
                        int&nbsp;pyrBorder,
                        int&nbsp;derivBorder,
                        boolean&nbsp;tryReuseInputImage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcGlobalOrientation</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                      double&nbsp;timestamp,
                      double&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a global motion orientation in a selected region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcMotionGradient</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                   <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                   <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                   double&nbsp;delta1,
                   double&nbsp;delta2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a gradient orientation of a motion history image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">calcMotionGradient</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                   <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                   <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                   double&nbsp;delta1,
                   double&nbsp;delta2,
                   int&nbsp;apertureSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a gradient orientation of a motion history image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)">calcOpticalFlowFarneback</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prev,
                         <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;next,
                         <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                         double&nbsp;pyr_scale,
                         int&nbsp;levels,
                         int&nbsp;winsize,
                         int&nbsp;iterations,
                         int&nbsp;poly_n,
                         double&nbsp;poly_sigma,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes a dense optical flow using the Gunnar Farneback's algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)">calcOpticalFlowPyrLK</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                     <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                     <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)">calcOpticalFlowPyrLK</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                     <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                     <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err,
                     <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                     int&nbsp;maxLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)">calcOpticalFlowPyrLK</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                     <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                     <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                     <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err,
                     <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                     int&nbsp;maxLevel,
                     <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria,
                     int&nbsp;flags,
                     double&nbsp;minEigThreshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">calcOpticalFlowSF</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;from,
                  <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;to,
                  <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                  int&nbsp;layers,
                  int&nbsp;averaging_block_size,
                  int&nbsp;max_flow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate an optical flow using "SimpleFlow" algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)">calcOpticalFlowSF</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;from,
                  <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;to,
                  <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                  int&nbsp;layers,
                  int&nbsp;averaging_block_size,
                  int&nbsp;max_flow,
                  double&nbsp;sigma_dist,
                  double&nbsp;sigma_color,
                  int&nbsp;postprocess_window,
                  double&nbsp;sigma_dist_fix,
                  double&nbsp;sigma_color_fix,
                  double&nbsp;occ_thr,
                  int&nbsp;upscale_averaging_radius,
                  double&nbsp;upscale_sigma_dist,
                  double&nbsp;upscale_sigma_color,
                  double&nbsp;speed_up_thr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate an optical flow using "SimpleFlow" algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">CamShift</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;probImage,
         <A HREF="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</A>&nbsp;window,
         <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds an object center, size, and orientation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">estimateRigidTransform</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;src,
                       <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;dst,
                       boolean&nbsp;fullAffine)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes an optimal affine transformation between two 2D point sets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">meanShift</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;probImage,
          <A HREF="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</A>&nbsp;window,
          <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds an object on a back projection image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)">segmentMotion</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
              <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;segmask,
              <A HREF="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</A>&nbsp;boundingRects,
              double&nbsp;timestamp,
              double&nbsp;segThresh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits a motion history image into a few parts corresponding to separate
 independent motions (for example, left hand, right hand).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/opencv/video/Video.html#updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">updateMotionHistory</A></B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;silhouette,
                    <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                    double&nbsp;timestamp,
                    double&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the motion history image by a moving silhouette.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="OPTFLOW_FARNEBACK_GAUSSIAN"><!-- --></A><H3>
OPTFLOW_FARNEBACK_GAUSSIAN</H3>
<PRE>
public static final int <B>OPTFLOW_FARNEBACK_GAUSSIAN</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_FARNEBACK_GAUSSIAN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPTFLOW_LK_GET_MIN_EIGENVALS"><!-- --></A><H3>
OPTFLOW_LK_GET_MIN_EIGENVALS</H3>
<PRE>
public static final int <B>OPTFLOW_LK_GET_MIN_EIGENVALS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_LK_GET_MIN_EIGENVALS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPTFLOW_USE_INITIAL_FLOW"><!-- --></A><H3>
OPTFLOW_USE_INITIAL_FLOW</H3>
<PRE>
public static final int <B>OPTFLOW_USE_INITIAL_FLOW</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_USE_INITIAL_FLOW">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Video()"><!-- --></A><H3>
Video</H3>
<PRE>
public <B>Video</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)"><!-- --></A><H3>
buildOpticalFlowPyramid</H3>
<PRE>
public static int <B>buildOpticalFlowPyramid</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;img,
                                          java.util.List&lt;<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&gt;&nbsp;pyramid,
                                          <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                                          int&nbsp;maxLevel)</PRE>
<DL>
<DD><p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - 8-bit input image.<DD><CODE>pyramid</CODE> - output pyramid.<DD><CODE>winSize</CODE> - window size of optical flow algorithm. Must be not less than
 <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
 calculate required padding for pyramid levels.<DD><CODE>maxLevel</CODE> - 0-based maximal pyramid level number.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a></DL>
</DD>
</DL>
<HR>

<A NAME="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)"><!-- --></A><H3>
buildOpticalFlowPyramid</H3>
<PRE>
public static int <B>buildOpticalFlowPyramid</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;img,
                                          java.util.List&lt;<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&gt;&nbsp;pyramid,
                                          <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                                          int&nbsp;maxLevel,
                                          boolean&nbsp;withDerivatives,
                                          int&nbsp;pyrBorder,
                                          int&nbsp;derivBorder,
                                          boolean&nbsp;tryReuseInputImage)</PRE>
<DL>
<DD><p>Constructs the image pyramid which can be passed to "calcOpticalFlowPyrLK".</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - 8-bit input image.<DD><CODE>pyramid</CODE> - output pyramid.<DD><CODE>winSize</CODE> - window size of optical flow algorithm. Must be not less than
 <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
 calculate required padding for pyramid levels.<DD><CODE>maxLevel</CODE> - 0-based maximal pyramid level number.<DD><CODE>withDerivatives</CODE> - set to precompute gradients for the every pyramid
 level. If pyramid is constructed without the gradients then "calcOpticalFlowPyrLK"
 will calculate them internally.<DD><CODE>pyrBorder</CODE> - the border mode for pyramid layers.<DD><CODE>derivBorder</CODE> - the border mode for gradients.<DD><CODE>tryReuseInputImage</CODE> - put ROI of input image into the pyramid if
 possible. You can pass <code>false</code> to force data copying.

 <p>:return: number of levels in constructed pyramid. Can be less than
 <code>maxLevel</code>.</p><DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)"><!-- --></A><H3>
calcGlobalOrientation</H3>
<PRE>
public static double <B>calcGlobalOrientation</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                                           <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                                           <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                                           double&nbsp;timestamp,
                                           double&nbsp;duration)</PRE>
<DL>
<DD><p>Calculates a global motion orientation in a selected region.</p>

 <p>The function calculates an average motion direction in the selected region
 and returns the angle between 0 degrees and 360 degrees. The average
 direction is computed from the weighted orientation histogram, where a recent
 motion has a larger weight and the motion occurred in the past has a smaller
 weight, as recorded in <code>mhi</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>orientation</CODE> - Motion gradient orientation image calculated by the
 function "calcMotionGradient".<DD><CODE>mask</CODE> - Mask image. It may be a conjunction of a valid gradient mask,
 also calculated by "calcMotionGradient", and the mask of a region whose
 direction needs to be calculated.<DD><CODE>mhi</CODE> - Motion history image calculated by "updateMotionHistory".<DD><CODE>timestamp</CODE> - Timestamp passed to "updateMotionHistory".<DD><CODE>duration</CODE> - Maximum duration of a motion track in milliseconds, passed to
 "updateMotionHistory".<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcglobalorientation">org.opencv.video.Video.calcGlobalOrientation</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)"><!-- --></A><H3>
calcMotionGradient</H3>
<PRE>
public static void <B>calcMotionGradient</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                                      double&nbsp;delta1,
                                      double&nbsp;delta2)</PRE>
<DL>
<DD><p>Calculates a gradient orientation of a motion history image.</p>

 <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
 as:</p>

 <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

 <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
 measured in degrees and covers the full range 0..360. Also, the
 <code>mask</code> is filled to indicate pixels where the computed angle is
 valid.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) An example on how to perform a motion template technique can
 be found at opencv_source_code/samples/python2/motempl.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mhi</CODE> - Motion history single-channel floating-point image.<DD><CODE>mask</CODE> - Output mask image that has the type <code>CV_8UC1</code> and the
 same size as <code>mhi</code>. Its non-zero elements mark pixels where the
 motion gradient data is correct.<DD><CODE>orientation</CODE> - Output motion gradient orientation image that has the same
 type and the same size as <code>mhi</code>. Each pixel of the image is a
 motion orientation, from 0 to 360 degrees.<DD><CODE>delta1</CODE> - Minimal (or maximal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood.<DD><CODE>delta2</CODE> - Maximal (or minimal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood. That is, the function
 finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
 <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
 marks the motion orientation at <em>(x, y)</em> as valid only if

 <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p><DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)"><!-- --></A><H3>
calcMotionGradient</H3>
<PRE>
public static void <B>calcMotionGradient</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mask,
                                      <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;orientation,
                                      double&nbsp;delta1,
                                      double&nbsp;delta2,
                                      int&nbsp;apertureSize)</PRE>
<DL>
<DD><p>Calculates a gradient orientation of a motion history image.</p>

 <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
 as:</p>

 <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

 <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
 measured in degrees and covers the full range 0..360. Also, the
 <code>mask</code> is filled to indicate pixels where the computed angle is
 valid.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) An example on how to perform a motion template technique can
 be found at opencv_source_code/samples/python2/motempl.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mhi</CODE> - Motion history single-channel floating-point image.<DD><CODE>mask</CODE> - Output mask image that has the type <code>CV_8UC1</code> and the
 same size as <code>mhi</code>. Its non-zero elements mark pixels where the
 motion gradient data is correct.<DD><CODE>orientation</CODE> - Output motion gradient orientation image that has the same
 type and the same size as <code>mhi</code>. Each pixel of the image is a
 motion orientation, from 0 to 360 degrees.<DD><CODE>delta1</CODE> - Minimal (or maximal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood.<DD><CODE>delta2</CODE> - Maximal (or minimal) allowed difference between
 <code>mhi</code> values within a pixel neighborhood. That is, the function
 finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
 <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
 marks the motion orientation at <em>(x, y)</em> as valid only if

 <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p><DD><CODE>apertureSize</CODE> - Aperture size of the "Sobel" operator.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)"><!-- --></A><H3>
calcOpticalFlowFarneback</H3>
<PRE>
public static void <B>calcOpticalFlowFarneback</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prev,
                                            <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;next,
                                            <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                                            double&nbsp;pyr_scale,
                                            int&nbsp;levels,
                                            int&nbsp;winsize,
                                            int&nbsp;iterations,
                                            int&nbsp;poly_n,
                                            double&nbsp;poly_sigma,
                                            int&nbsp;flags)</PRE>
<DL>
<DD><p>Computes a dense optical flow using the Gunnar Farneback's algorithm.</p>

 <p>The function finds an optical flow for each <code>prev</code> pixel using the
 [Farneback2003] algorithm so that</p>

 <p><em>prev(y,x) ~ next(y + flow(y,x)[1], x + flow(y,x)[0])</em></p>

 <p>Note:</p>
 <ul>
   <li> An example using the optical flow algorithm described by Gunnar
 Farneback can be found at opencv_source_code/samples/cpp/fback.cpp
   <li> (Python) An example using the optical flow algorithm described by
 Gunnar Farneback can be found at opencv_source_code/samples/python2/opt_flow.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prev</CODE> - first 8-bit single-channel input image.<DD><CODE>next</CODE> - second input image of the same size and the same type as
 <code>prev</code>.<DD><CODE>flow</CODE> - computed flow image that has the same size as <code>prev</code>
 and type <code>CV_32FC2</code>.<DD><CODE>pyr_scale</CODE> - parameter, specifying the image scale (<1) to build pyramids
 for each image; <code>pyr_scale=0.5</code> means a classical pyramid, where
 each next layer is twice smaller than the previous one.<DD><CODE>levels</CODE> - number of pyramid layers including the initial image;
 <code>levels=1</code> means that no extra layers are created and only the
 original images are used.<DD><CODE>winsize</CODE> - averaging window size; larger values increase the algorithm
 robustness to image noise and give more chances for fast motion detection,
 but yield more blurred motion field.<DD><CODE>iterations</CODE> - number of iterations the algorithm does at each pyramid
 level.<DD><CODE>poly_n</CODE> - size of the pixel neighborhood used to find polynomial
 expansion in each pixel; larger values mean that the image will be
 approximated with smoother surfaces, yielding more robust algorithm and more
 blurred motion field, typically <code>poly_n</code> =5 or 7.<DD><CODE>poly_sigma</CODE> - standard deviation of the Gaussian that is used to smooth
 derivatives used as a basis for the polynomial expansion; for
 <code>poly_n=5</code>, you can set <code>poly_sigma=1.1</code>, for
 <code>poly_n=7</code>, a good value would be <code>poly_sigma=1.5</code>.<DD><CODE>flags</CODE> - operation flags that can be a combination of the following:
 <ul>
   <li> OPTFLOW_USE_INITIAL_FLOW uses the input <code>flow</code> as an
 initial flow approximation.
   <li> OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian <em>winsizexwinsize</em>
 filter instead of a box filter of the same size for optical flow estimation;
 usually, this option gives z more accurate flow than with a box filter, at
 the cost of lower speed; normally, <code>winsize</code> for a Gaussian window
 should be set to a larger value to achieve the same level of robustness.
 </ul><DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">org.opencv.video.Video.calcOpticalFlowFarneback</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)"><!-- --></A><H3>
calcOpticalFlowPyrLK</H3>
<PRE>
public static void <B>calcOpticalFlowPyrLK</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                                        <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                                        <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                                        <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err)</PRE>
<DL>
<DD><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prevImg</CODE> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".<DD><CODE>nextImg</CODE> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.<DD><CODE>prevPts</CODE> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.<DD><CODE>nextPts</CODE> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.<DD><CODE>status</CODE> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.<DD><CODE>err</CODE> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)"><!-- --></A><H3>
calcOpticalFlowPyrLK</H3>
<PRE>
public static void <B>calcOpticalFlowPyrLK</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                                        <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                                        <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                                        <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err,
                                        <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                                        int&nbsp;maxLevel)</PRE>
<DL>
<DD><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prevImg</CODE> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".<DD><CODE>nextImg</CODE> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.<DD><CODE>prevPts</CODE> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.<DD><CODE>nextPts</CODE> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.<DD><CODE>status</CODE> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.<DD><CODE>err</CODE> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).<DD><CODE>winSize</CODE> - size of the search window at each pyramid level.<DD><CODE>maxLevel</CODE> - 0-based maximal pyramid level number; if set to 0, pyramids
 are not used (single level), if set to 1, two levels are used, and so on; if
 pyramids are passed to input then algorithm will use as many levels as
 pyramids have but no more than <code>maxLevel</code>.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)"><!-- --></A><H3>
calcOpticalFlowPyrLK</H3>
<PRE>
public static void <B>calcOpticalFlowPyrLK</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;prevImg,
                                        <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;nextImg,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;prevPts,
                                        <A HREF="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</A>&nbsp;nextPts,
                                        <A HREF="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</A>&nbsp;status,
                                        <A HREF="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</A>&nbsp;err,
                                        <A HREF="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</A>&nbsp;winSize,
                                        int&nbsp;maxLevel,
                                        <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria,
                                        int&nbsp;flags,
                                        double&nbsp;minEigThreshold)</PRE>
<DL>
<DD><p>Calculates an optical flow for a sparse feature set using the iterative
 Lucas-Kanade method with pyramids.</p>

 <p>The function implements a sparse iterative version of the Lucas-Kanade
 optical flow in pyramids. See [Bouguet00]. The function is parallelized with
 the TBB library.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the Lucas-Kanade optical flow algorithm can be found
 at opencv_source_code/samples/cpp/lkdemo.cpp
   <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
 be found at opencv_source_code/samples/python2/lk_track.py
   <li> (Python) An example using the Lucas-Kanade tracker for homography
 matching can be found at opencv_source_code/samples/python2/lk_homography.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prevImg</CODE> - first 8-bit input image or pyramid constructed by
 "buildOpticalFlowPyramid".<DD><CODE>nextImg</CODE> - second input image or pyramid of the same size and the same
 type as <code>prevImg</code>.<DD><CODE>prevPts</CODE> - vector of 2D points for which the flow needs to be found;
 point coordinates must be single-precision floating-point numbers.<DD><CODE>nextPts</CODE> - output vector of 2D points (with single-precision
 floating-point coordinates) containing the calculated new positions of input
 features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
 is passed, the vector must have the same size as in the input.<DD><CODE>status</CODE> - output status vector (of unsigned chars); each element of the
 vector is set to 1 if the flow for the corresponding features has been found,
 otherwise, it is set to 0.<DD><CODE>err</CODE> - output vector of errors; each element of the vector is set to an
 error for the corresponding feature, type of the error measure can be set in
 <code>flags</code> parameter; if the flow wasn't found then the error is not
 defined (use the <code>status</code> parameter to find such cases).<DD><CODE>winSize</CODE> - size of the search window at each pyramid level.<DD><CODE>maxLevel</CODE> - 0-based maximal pyramid level number; if set to 0, pyramids
 are not used (single level), if set to 1, two levels are used, and so on; if
 pyramids are passed to input then algorithm will use as many levels as
 pyramids have but no more than <code>maxLevel</code>.<DD><CODE>criteria</CODE> - parameter, specifying the termination criteria of the
 iterative search algorithm (after the specified maximum number of iterations
 <code>criteria.maxCount</code> or when the search window moves by less than
 <code>criteria.epsilon</code>.<DD><CODE>flags</CODE> - operation flags:
 <ul>
   <li> OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in
 <code>nextPts</code>; if the flag is not set, then <code>prevPts</code> is
 copied to <code>nextPts</code> and is considered the initial estimate.
   <li> OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error
 measure (see <code>minEigThreshold</code> description); if the flag is not
 set, then L1 distance between patches around the original and a moved point,
 divided by number of pixels in a window, is used as a error measure.
 </ul><DD><CODE>minEigThreshold</CODE> - the algorithm calculates the minimum eigen value of a
 2x2 normal matrix of optical flow equations (this matrix is called a spatial
 gradient matrix in [Bouguet00]), divided by number of pixels in a window; if
 this value is less than <code>minEigThreshold</code>, then a corresponding
 feature is filtered out and its flow is not processed, so it allows to remove
 bad points and get a performance boost.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><!-- --></A><H3>
calcOpticalFlowSF</H3>
<PRE>
public static void <B>calcOpticalFlowSF</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;from,
                                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;to,
                                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                                     int&nbsp;layers,
                                     int&nbsp;averaging_block_size,
                                     int&nbsp;max_flow)</PRE>
<DL>
<DD><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

 <p>See [Tao2012]. And site of project - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the simpleFlow algorithm can be found at
 opencv_source_code/samples/cpp/simpleflow_demo.cpp
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - a from<DD><CODE>to</CODE> - a to<DD><CODE>flow</CODE> - a flow<DD><CODE>layers</CODE> - Number of layers<DD><CODE>averaging_block_size</CODE> - Size of block through which we sum up when
 calculate cost function for pixel<DD><CODE>max_flow</CODE> - maximal flow that we search at each level<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a></DL>
</DD>
</DL>
<HR>

<A NAME="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)"><!-- --></A><H3>
calcOpticalFlowSF</H3>
<PRE>
public static void <B>calcOpticalFlowSF</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;from,
                                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;to,
                                     <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;flow,
                                     int&nbsp;layers,
                                     int&nbsp;averaging_block_size,
                                     int&nbsp;max_flow,
                                     double&nbsp;sigma_dist,
                                     double&nbsp;sigma_color,
                                     int&nbsp;postprocess_window,
                                     double&nbsp;sigma_dist_fix,
                                     double&nbsp;sigma_color_fix,
                                     double&nbsp;occ_thr,
                                     int&nbsp;upscale_averaging_radius,
                                     double&nbsp;upscale_sigma_dist,
                                     double&nbsp;upscale_sigma_color,
                                     double&nbsp;speed_up_thr)</PRE>
<DL>
<DD><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

 <p>See [Tao2012]. And site of project - http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

 <p>Note:</p>
 <ul>
   <li> An example using the simpleFlow algorithm can be found at
 opencv_source_code/samples/cpp/simpleflow_demo.cpp
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - a from<DD><CODE>to</CODE> - a to<DD><CODE>flow</CODE> - a flow<DD><CODE>layers</CODE> - Number of layers<DD><CODE>averaging_block_size</CODE> - Size of block through which we sum up when
 calculate cost function for pixel<DD><CODE>max_flow</CODE> - maximal flow that we search at each level<DD><CODE>sigma_dist</CODE> - vector smooth spatial sigma parameter<DD><CODE>sigma_color</CODE> - vector smooth color sigma parameter<DD><CODE>postprocess_window</CODE> - window size for postprocess cross bilateral filter<DD><CODE>sigma_dist_fix</CODE> - spatial sigma for postprocess cross bilateralf filter<DD><CODE>sigma_color_fix</CODE> - color sigma for postprocess cross bilateral filter<DD><CODE>occ_thr</CODE> - threshold for detecting occlusions<DD><CODE>upscale_averaging_radius</CODE> - a upscale_averaging_radius<DD><CODE>upscale_sigma_dist</CODE> - spatial sigma for bilateral upscale operation<DD><CODE>upscale_sigma_color</CODE> - color sigma for bilateral upscale operation<DD><CODE>speed_up_thr</CODE> - threshold to detect point with irregular flow - where
 flow should be recalculated after upscale<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a></DL>
</DD>
</DL>
<HR>

<A NAME="CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)"><!-- --></A><H3>
CamShift</H3>
<PRE>
public static <A HREF="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</A> <B>CamShift</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;probImage,
                                   <A HREF="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</A>&nbsp;window,
                                   <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria)</PRE>
<DL>
<DD><p>Finds an object center, size, and orientation.</p>

 <p>The function implements the CAMSHIFT object tracking algorithm [Bradski98].
 First, it finds an object center using "meanShift" and then adjusts the
 window size and finds the optimal rotation. The function returns the rotated
 rectangle structure that includes the object position, size, and orientation.
 The next position of the search window can be obtained with <code>RotatedRect.boundingRect()</code>.</p>

 <p>See the OpenCV sample <code>camshiftdemo.c</code> that tracks colored
 objects.</p>

 <p>Note:</p>
 <ul>
   <li> (Python) A sample explaining the camshift tracking algorithm can be
 found at opencv_source_code/samples/python2/camshift.py
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>probImage</CODE> - Back projection of the object histogram. See
 "calcBackProject".<DD><CODE>window</CODE> - Initial search window.<DD><CODE>criteria</CODE> - Stop criteria for the underlying "meanShift".

 <p>:returns: (in old interfaces) Number of iterations CAMSHIFT took to converge</p><DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#camshift">org.opencv.video.Video.CamShift</a></DL>
</DD>
</DL>
<HR>

<A NAME="estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><!-- --></A><H3>
estimateRigidTransform</H3>
<PRE>
public static <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A> <B>estimateRigidTransform</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;src,
                                         <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;dst,
                                         boolean&nbsp;fullAffine)</PRE>
<DL>
<DD><p>Computes an optimal affine transformation between two 2D point sets.</p>

 <p>The function finds an optimal affine transform *[A|b]* (a <code>2 x 3</code>
 floating-point matrix) that approximates best the affine transformation
 between:</p>
 <ul>
   <li> Two point sets
   <li> Two raster images. In this case, the function first finds some
 features in the <code>src</code> image and finds the corresponding features
 in <code>dst</code> image. After that, the problem is reduced to the first
 case.
 </ul>

 <p>In case of point sets, the problem is formulated as follows: you need to find
 a 2x2 matrix *A* and 2x1 vector *b* so that:</p>

 <p><em>[A^*|b^*] = arg min _([A|b]) sum _i|dst[i] - A (src[i])^T - b| ^2</em></p>

 <p>where <code>src[i]</code> and <code>dst[i]</code> are the i-th points in
 <code>src</code> and <code>dst</code>, respectively</p>

 <p><em>[A|b]</em> can be either arbitrary (when <code>fullAffine=true</code>) or
 have a form of</p>

 <p><em>a_11 a_12 b_1
 -a_12 a_11 b_2 </em></p>

 <p>when <code>fullAffine=false</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - First input 2D point set stored in <code>std.vector</code> or
 <code>Mat</code>, or an image stored in <code>Mat</code>.<DD><CODE>dst</CODE> - Second input 2D point set of the same size and the same type as
 <code>A</code>, or another image.<DD><CODE>fullAffine</CODE> - If true, the function finds an optimal affine
 transformation with no additional restrictions (6 degrees of freedom).
 Otherwise, the class of transformations to choose from is limited to
 combinations of translation, rotation, and uniform scaling (5 degrees of
 freedom).<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#estimaterigidtransform">org.opencv.video.Video.estimateRigidTransform</a>, 
<A HREF="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)"><CODE>Calib3d.findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)</CODE></A>, 
<A HREF="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><CODE>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)</CODE></A>, 
<A HREF="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><CODE>Imgproc.getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)"><!-- --></A><H3>
meanShift</H3>
<PRE>
public static int <B>meanShift</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;probImage,
                            <A HREF="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</A>&nbsp;window,
                            <A HREF="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</A>&nbsp;criteria)</PRE>
<DL>
<DD><p>Finds an object on a back projection image.</p>

 <p>The function implements the iterative object search algorithm. It takes the
 input back projection of an object and the initial position. The mass center
 in <code>window</code> of the back projection image is computed and the
 search window center shifts to the mass center. The procedure is repeated
 until the specified number of iterations <code>criteria.maxCount</code> is
 done or until the window center shifts by less than <code>criteria.epsilon</code>.
 The algorithm is used inside "CamShift" and, unlike "CamShift", the search
 window size or orientation do not change during the search. You can simply
 pass the output of "calcBackProject" to this function. But better results can
 be obtained if you pre-filter the back projection and remove the noise. For
 example, you can do this by retrieving connected components with
 "findContours", throwing away contours with small area ("contourArea"), and
 rendering the remaining contours with "drawContours".</p>

 <p>Note:</p>
 <ul>
   <li> A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>probImage</CODE> - Back projection of the object histogram. See
 "calcBackProject" for details.<DD><CODE>window</CODE> - Initial search window.<DD><CODE>criteria</CODE> - Stop criteria for the iterative search algorithm.

 <p>:returns: Number of iterations CAMSHIFT took to converge.</p><DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#meanshift">org.opencv.video.Video.meanShift</a></DL>
</DD>
</DL>
<HR>

<A NAME="segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)"><!-- --></A><H3>
segmentMotion</H3>
<PRE>
public static void <B>segmentMotion</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                                 <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;segmask,
                                 <A HREF="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</A>&nbsp;boundingRects,
                                 double&nbsp;timestamp,
                                 double&nbsp;segThresh)</PRE>
<DL>
<DD><p>Splits a motion history image into a few parts corresponding to separate
 independent motions (for example, left hand, right hand).</p>

 <p>The function finds all of the motion segments and marks them in
 <code>segmask</code> with individual values (1,2,...). It also computes a
 vector with ROIs of motion connected components. After that the motion
 direction for every component can be calculated with "calcGlobalOrientation"
 using the extracted mask of the particular component.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mhi</CODE> - Motion history image.<DD><CODE>segmask</CODE> - Image where the found mask should be stored, single-channel,
 32-bit floating-point.<DD><CODE>boundingRects</CODE> - Vector containing ROIs of motion connected components.<DD><CODE>timestamp</CODE> - Current time in milliseconds or other units.<DD><CODE>segThresh</CODE> - Segmentation threshold that is recommended to be equal to
 the interval between motion history "steps" or greater.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#segmentmotion">org.opencv.video.Video.segmentMotion</a></DL>
</DD>
</DL>
<HR>

<A NAME="updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)"><!-- --></A><H3>
updateMotionHistory</H3>
<PRE>
public static void <B>updateMotionHistory</B>(<A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;silhouette,
                                       <A HREF="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</A>&nbsp;mhi,
                                       double&nbsp;timestamp,
                                       double&nbsp;duration)</PRE>
<DL>
<DD><p>Updates the motion history image by a moving silhouette.</p>

 <p>The function updates the motion history image as follows:</p>

 <p><em>mhi(x,y)= timestamp if silhouette(x,y) != 0; 0 if silhouette(x,y) = 0 and
 mhi &lt(timestamp - duration); mhi(x,y) otherwise</em></p>

 <p>That is, MHI pixels where the motion occurs are set to the current
 <code>timestamp</code>, while the pixels where the motion happened last time
 a long time ago are cleared.</p>

 <p>The function, together with "calcMotionGradient" and "calcGlobalOrientation",
 implements a motion templates technique described in [Davis97] and
 [Bradski00].
 See also the OpenCV sample <code>motempl.c</code> that demonstrates the use
 of all the motion template functions.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>silhouette</CODE> - Silhouette mask that has non-zero pixels where the motion
 occurs.<DD><CODE>mhi</CODE> - Motion history image that is updated by the function
 (single-channel, 32-bit floating-point).<DD><CODE>timestamp</CODE> - Current time in milliseconds or other units.<DD><CODE>duration</CODE> - Maximal duration of the motion track in the same units as
 <code>timestamp</code>.<DT><B>See Also:</B><DD><a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#updatemotionhistory">org.opencv.video.Video.updateMotionHistory</a></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href=http://docs.opencv.org>OpenCV 2.4.8 Documentation</a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/opencv/video/Video.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Video.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
